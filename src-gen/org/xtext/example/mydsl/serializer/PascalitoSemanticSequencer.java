/*
 * generated by Xtext 2.10.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.services.PascalitoGrammarAccess;
import pascalito.Atribuition;
import pascalito.Block;
import pascalito.CallProc;
import pascalito.CallProcExp;
import pascalito.CallVariable;
import pascalito.ExpBinLogical;
import pascalito.ExpBinNv0;
import pascalito.ExpBinNv1;
import pascalito.ExpNeg;
import pascalito.If;
import pascalito.Loop;
import pascalito.NumberLiteral;
import pascalito.PascalitoPackage;
import pascalito.Procedure;
import pascalito.Program;
import pascalito.Variable;

@SuppressWarnings("all")
public class PascalitoSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private PascalitoGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == PascalitoPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case PascalitoPackage.ATRIBUITION:
				sequence_Atribuition(context, (Atribuition) semanticObject); 
				return; 
			case PascalitoPackage.BLOCK:
				sequence_Block(context, (Block) semanticObject); 
				return; 
			case PascalitoPackage.CALL_PROC:
				sequence_CallProc(context, (CallProc) semanticObject); 
				return; 
			case PascalitoPackage.CALL_PROC_EXP:
				sequence_CallProcExp(context, (CallProcExp) semanticObject); 
				return; 
			case PascalitoPackage.CALL_VARIABLE:
				sequence_CallVariable(context, (CallVariable) semanticObject); 
				return; 
			case PascalitoPackage.EXP_BIN_LOGICAL:
				sequence_ExpBinLogical(context, (ExpBinLogical) semanticObject); 
				return; 
			case PascalitoPackage.EXP_BIN_NV0:
				sequence_ExpBinNv0(context, (ExpBinNv0) semanticObject); 
				return; 
			case PascalitoPackage.EXP_BIN_NV1:
				sequence_ExpBinNv1(context, (ExpBinNv1) semanticObject); 
				return; 
			case PascalitoPackage.EXP_NEG:
				sequence_ExpNeg(context, (ExpNeg) semanticObject); 
				return; 
			case PascalitoPackage.IF:
				sequence_If(context, (If) semanticObject); 
				return; 
			case PascalitoPackage.LOOP:
				sequence_Loop(context, (Loop) semanticObject); 
				return; 
			case PascalitoPackage.NUMBER_LITERAL:
				sequence_NumberLiteral(context, (NumberLiteral) semanticObject); 
				return; 
			case PascalitoPackage.PROCEDURE:
				sequence_Procedure(context, (Procedure) semanticObject); 
				return; 
			case PascalitoPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case PascalitoPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Command returns Atribuition
	 *     Atribuition returns Atribuition
	 *
	 * Constraint:
	 *     (sets=[Variable|ID] atribuiResultado=Expression)
	 */
	protected void sequence_Atribuition(ISerializationContext context, Atribuition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalitoPackage.Literals.ATRIBUITION__SETS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalitoPackage.Literals.ATRIBUITION__SETS));
			if (transientValues.isValueTransient(semanticObject, PascalitoPackage.Literals.ATRIBUITION__ATRIBUI_RESULTADO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalitoPackage.Literals.ATRIBUITION__ATRIBUI_RESULTADO));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtribuitionAccess().getSetsVariableIDTerminalRuleCall_0_0_1(), semanticObject.getSets());
		feeder.accept(grammarAccess.getAtribuitionAccess().getAtribuiResultadoExpressionParserRuleCall_2_0(), semanticObject.getAtribuiResultado());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Block returns Block
	 *
	 * Constraint:
	 *     ((defVariable+=Variable defVariable+=Variable*)* defprocedure+=Procedure* execute+=Command*)
	 */
	protected void sequence_Block(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns CallProcExp
	 *     CallProcExp returns CallProcExp
	 *     ExpBinNv0 returns CallProcExp
	 *     ExpBinNv0.ExpBinNv0_1_0 returns CallProcExp
	 *     ExpBinNv1 returns CallProcExp
	 *     ExpBinNv1.ExpBinNv1_1_0 returns CallProcExp
	 *     ExpBinLogical returns CallProcExp
	 *     ExpBinLogical.ExpBinLogical_1_0 returns CallProcExp
	 *     Primary returns CallProcExp
	 *
	 * Constraint:
	 *     (represent=[Procedure|ID] (parameter+=Expression parameter+=Expression*)?)
	 */
	protected void sequence_CallProcExp(ISerializationContext context, CallProcExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns CallProc
	 *     CallProc returns CallProc
	 *
	 * Constraint:
	 *     (defined=[Procedure|ID] (parameter+=Expression parameter+=Expression*)?)
	 */
	protected void sequence_CallProc(ISerializationContext context, CallProc semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns CallVariable
	 *     CallVariable returns CallVariable
	 *     ExpBinNv0 returns CallVariable
	 *     ExpBinNv0.ExpBinNv0_1_0 returns CallVariable
	 *     ExpBinNv1 returns CallVariable
	 *     ExpBinNv1.ExpBinNv1_1_0 returns CallVariable
	 *     ExpBinLogical returns CallVariable
	 *     ExpBinLogical.ExpBinLogical_1_0 returns CallVariable
	 *     Primary returns CallVariable
	 *
	 * Constraint:
	 *     represent=[Variable|ID]
	 */
	protected void sequence_CallVariable(ISerializationContext context, CallVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalitoPackage.Literals.CALL_VARIABLE__REPRESENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalitoPackage.Literals.CALL_VARIABLE__REPRESENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCallVariableAccess().getRepresentVariableIDTerminalRuleCall_0_1(), semanticObject.getRepresent());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpBinLogical
	 *     ExpBinNv0 returns ExpBinLogical
	 *     ExpBinNv0.ExpBinNv0_1_0 returns ExpBinLogical
	 *     ExpBinNv1 returns ExpBinLogical
	 *     ExpBinNv1.ExpBinNv1_1_0 returns ExpBinLogical
	 *     ExpBinLogical returns ExpBinLogical
	 *     ExpBinLogical.ExpBinLogical_1_0 returns ExpBinLogical
	 *     Primary returns ExpBinLogical
	 *
	 * Constraint:
	 *     (left=ExpBinLogical_ExpBinLogical_1_0 right=Primary)
	 */
	protected void sequence_ExpBinLogical(ISerializationContext context, ExpBinLogical semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalitoPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalitoPackage.Literals.EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, PascalitoPackage.Literals.EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalitoPackage.Literals.EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpBinLogicalAccess().getExpBinLogicalLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpBinLogicalAccess().getRightPrimaryParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpBinNv0
	 *     ExpBinNv0 returns ExpBinNv0
	 *     ExpBinNv0.ExpBinNv0_1_0 returns ExpBinNv0
	 *     ExpBinNv1 returns ExpBinNv0
	 *     ExpBinNv1.ExpBinNv1_1_0 returns ExpBinNv0
	 *     ExpBinLogical returns ExpBinNv0
	 *     ExpBinLogical.ExpBinLogical_1_0 returns ExpBinNv0
	 *     Primary returns ExpBinNv0
	 *
	 * Constraint:
	 *     (left=ExpBinNv0_ExpBinNv0_1_0 right=ExpBinNv1)
	 */
	protected void sequence_ExpBinNv0(ISerializationContext context, ExpBinNv0 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalitoPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalitoPackage.Literals.EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, PascalitoPackage.Literals.EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalitoPackage.Literals.EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpBinNv0Access().getExpBinNv0LeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpBinNv0Access().getRightExpBinNv1ParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpBinNv1
	 *     ExpBinNv0 returns ExpBinNv1
	 *     ExpBinNv0.ExpBinNv0_1_0 returns ExpBinNv1
	 *     ExpBinNv1 returns ExpBinNv1
	 *     ExpBinNv1.ExpBinNv1_1_0 returns ExpBinNv1
	 *     ExpBinLogical returns ExpBinNv1
	 *     ExpBinLogical.ExpBinLogical_1_0 returns ExpBinNv1
	 *     Primary returns ExpBinNv1
	 *
	 * Constraint:
	 *     (left=ExpBinNv1_ExpBinNv1_1_0 right=ExpBinLogical)
	 */
	protected void sequence_ExpBinNv1(ISerializationContext context, ExpBinNv1 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalitoPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalitoPackage.Literals.EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, PascalitoPackage.Literals.EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalitoPackage.Literals.EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpBinNv1Access().getExpBinNv1LeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpBinNv1Access().getRightExpBinLogicalParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpNeg
	 *     ExpNeg returns ExpNeg
	 *
	 * Constraint:
	 *     negate=Expression
	 */
	protected void sequence_ExpNeg(ISerializationContext context, ExpNeg semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalitoPackage.Literals.EXP_NEG__NEGATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalitoPackage.Literals.EXP_NEG__NEGATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpNegAccess().getNegateExpressionParserRuleCall_1_0(), semanticObject.getNegate());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns If
	 *     If returns If
	 *
	 * Constraint:
	 *     (ifExp=Expression do+=Command* elseCmd+=Command*)
	 */
	protected void sequence_If(ISerializationContext context, If semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns Loop
	 *     Loop returns Loop
	 *
	 * Constraint:
	 *     (while=Expression do+=Command*)
	 */
	protected void sequence_Loop(ISerializationContext context, Loop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NumberLiteral
	 *     ExpBinNv0 returns NumberLiteral
	 *     ExpBinNv0.ExpBinNv0_1_0 returns NumberLiteral
	 *     ExpBinNv1 returns NumberLiteral
	 *     ExpBinNv1.ExpBinNv1_1_0 returns NumberLiteral
	 *     ExpBinLogical returns NumberLiteral
	 *     ExpBinLogical.ExpBinLogical_1_0 returns NumberLiteral
	 *     Primary returns NumberLiteral
	 *     NumberLiteral returns NumberLiteral
	 *
	 * Constraint:
	 *     {NumberLiteral}
	 */
	protected void sequence_NumberLiteral(ISerializationContext context, NumberLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Procedure returns Procedure
	 *
	 * Constraint:
	 *     (name=ID (parameter+=Variable parameter+=Variable*)? block=Block)
	 */
	protected void sequence_Procedure(ISerializationContext context, Procedure semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     (Ident=EString block=Block)
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalitoPackage.Literals.PROGRAM__IDENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalitoPackage.Literals.PROGRAM__IDENT));
			if (transientValues.isValueTransient(semanticObject, PascalitoPackage.Literals.PROGRAM__BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalitoPackage.Literals.PROGRAM__BLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProgramAccess().getIdentEStringParserRuleCall_1_0(), semanticObject.getIdent());
		feeder.accept(grammarAccess.getProgramAccess().getBlockBlockParserRuleCall_3_0(), semanticObject.getBlock());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalitoPackage.Literals.VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalitoPackage.Literals.VARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
}
