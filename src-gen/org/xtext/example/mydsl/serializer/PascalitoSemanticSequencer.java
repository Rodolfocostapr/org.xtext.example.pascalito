/*
 * generated by Xtext 2.10.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.services.PascalitoGrammarAccess;
import pascalito.Atribuicao;
import pascalito.Bloco;
import pascalito.CallProc;
import pascalito.CallProcedimento;
import pascalito.CallVariavel;
import pascalito.Comutativa;
import pascalito.Desvio;
import pascalito.ExpBinLogica;
import pascalito.ExpNeg;
import pascalito.Loop;
import pascalito.N_Comutativa;
import pascalito.NumberLiteral;
import pascalito.PascalitoPackage;
import pascalito.Procedimento;
import pascalito.Programa;
import pascalito.Variavel;

@SuppressWarnings("all")
public class PascalitoSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private PascalitoGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == PascalitoPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case PascalitoPackage.ATRIBUICAO:
				sequence_Atribuicao(context, (Atribuicao) semanticObject); 
				return; 
			case PascalitoPackage.BLOCO:
				sequence_Bloco(context, (Bloco) semanticObject); 
				return; 
			case PascalitoPackage.CALL_PROC:
				sequence_CallProc(context, (CallProc) semanticObject); 
				return; 
			case PascalitoPackage.CALL_PROCEDIMENTO:
				sequence_CallProcedimento(context, (CallProcedimento) semanticObject); 
				return; 
			case PascalitoPackage.CALL_VARIAVEL:
				sequence_CallVariavel(context, (CallVariavel) semanticObject); 
				return; 
			case PascalitoPackage.COMUTATIVA:
				sequence_Comutativa(context, (Comutativa) semanticObject); 
				return; 
			case PascalitoPackage.DESVIO:
				sequence_Desvio(context, (Desvio) semanticObject); 
				return; 
			case PascalitoPackage.EXP_BIN_LOGICA:
				sequence_ExpBinLogica(context, (ExpBinLogica) semanticObject); 
				return; 
			case PascalitoPackage.EXP_NEG:
				sequence_ExpNeg(context, (ExpNeg) semanticObject); 
				return; 
			case PascalitoPackage.LOOP:
				sequence_Loop(context, (Loop) semanticObject); 
				return; 
			case PascalitoPackage.NCOMUTATIVA:
				sequence_N_Comutativa(context, (N_Comutativa) semanticObject); 
				return; 
			case PascalitoPackage.NUMBER_LITERAL:
				sequence_NumberLiteral(context, (NumberLiteral) semanticObject); 
				return; 
			case PascalitoPackage.PROCEDIMENTO:
				sequence_Procedimento(context, (Procedimento) semanticObject); 
				return; 
			case PascalitoPackage.PROGRAMA:
				sequence_Programa(context, (Programa) semanticObject); 
				return; 
			case PascalitoPackage.VARIAVEL:
				sequence_Variavel(context, (Variavel) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Comando returns Atribuicao
	 *     Atribuicao returns Atribuicao
	 *
	 * Constraint:
	 *     (atribui=[Variavel|ID] atribuiResultado=Expressao)
	 */
	protected void sequence_Atribuicao(ISerializationContext context, Atribuicao semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalitoPackage.Literals.ATRIBUICAO__ATRIBUI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalitoPackage.Literals.ATRIBUICAO__ATRIBUI));
			if (transientValues.isValueTransient(semanticObject, PascalitoPackage.Literals.ATRIBUICAO__ATRIBUI_RESULTADO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalitoPackage.Literals.ATRIBUICAO__ATRIBUI_RESULTADO));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtribuicaoAccess().getAtribuiVariavelIDTerminalRuleCall_0_0_1(), semanticObject.getAtribui());
		feeder.accept(grammarAccess.getAtribuicaoAccess().getAtribuiResultadoExpressaoParserRuleCall_2_0(), semanticObject.getAtribuiResultado());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Bloco returns Bloco
	 *
	 * Constraint:
	 *     ((defvariavel+=Variavel defvariavel+=Variavel*)* defprocedimento+=Procedimento* executa+=Comando*)
	 */
	protected void sequence_Bloco(ISerializationContext context, Bloco semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expressao returns CallProc
	 *     CallProc returns CallProc
	 *     Comutativa returns CallProc
	 *     Comutativa.Comutativa_1_0 returns CallProc
	 *     N_Comutativa returns CallProc
	 *     N_Comutativa.N_Comutativa_1_0 returns CallProc
	 *     ExpBinLogica returns CallProc
	 *     ExpBinLogica.ExpBinLogica_1_0 returns CallProc
	 *     Primary returns CallProc
	 *
	 * Constraint:
	 *     (representaProc=[Procedimento|ID] (parametro+=Expressao parametro+=Expressao*)?)
	 */
	protected void sequence_CallProc(ISerializationContext context, CallProc semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Comando returns CallProcedimento
	 *     CallProcedimento returns CallProcedimento
	 *
	 * Constraint:
	 *     (definido=[Procedimento|ID] (parametro+=Expressao parametro+=Expressao*)?)
	 */
	protected void sequence_CallProcedimento(ISerializationContext context, CallProcedimento semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expressao returns CallVariavel
	 *     CallVariavel returns CallVariavel
	 *     Comutativa returns CallVariavel
	 *     Comutativa.Comutativa_1_0 returns CallVariavel
	 *     N_Comutativa returns CallVariavel
	 *     N_Comutativa.N_Comutativa_1_0 returns CallVariavel
	 *     ExpBinLogica returns CallVariavel
	 *     ExpBinLogica.ExpBinLogica_1_0 returns CallVariavel
	 *     Primary returns CallVariavel
	 *
	 * Constraint:
	 *     representa=[Variavel|ID]
	 */
	protected void sequence_CallVariavel(ISerializationContext context, CallVariavel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalitoPackage.Literals.CALL_VARIAVEL__REPRESENTA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalitoPackage.Literals.CALL_VARIAVEL__REPRESENTA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCallVariavelAccess().getRepresentaVariavelIDTerminalRuleCall_0_1(), semanticObject.getRepresenta());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expressao returns Comutativa
	 *     Comutativa returns Comutativa
	 *     Comutativa.Comutativa_1_0 returns Comutativa
	 *     N_Comutativa returns Comutativa
	 *     N_Comutativa.N_Comutativa_1_0 returns Comutativa
	 *     ExpBinLogica returns Comutativa
	 *     ExpBinLogica.ExpBinLogica_1_0 returns Comutativa
	 *     Primary returns Comutativa
	 *
	 * Constraint:
	 *     (left=Comutativa_Comutativa_1_0 right=N_Comutativa)
	 */
	protected void sequence_Comutativa(ISerializationContext context, Comutativa semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalitoPackage.Literals.EXPRESSAO__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalitoPackage.Literals.EXPRESSAO__LEFT));
			if (transientValues.isValueTransient(semanticObject, PascalitoPackage.Literals.EXPRESSAO__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalitoPackage.Literals.EXPRESSAO__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComutativaAccess().getComutativaLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComutativaAccess().getRightN_ComutativaParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Comando returns Desvio
	 *     Desvio returns Desvio
	 *
	 * Constraint:
	 *     (se=Expressao faca+=Comando* seNao+=Comando*)
	 */
	protected void sequence_Desvio(ISerializationContext context, Desvio semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expressao returns ExpBinLogica
	 *     Comutativa returns ExpBinLogica
	 *     Comutativa.Comutativa_1_0 returns ExpBinLogica
	 *     N_Comutativa returns ExpBinLogica
	 *     N_Comutativa.N_Comutativa_1_0 returns ExpBinLogica
	 *     ExpBinLogica returns ExpBinLogica
	 *     ExpBinLogica.ExpBinLogica_1_0 returns ExpBinLogica
	 *     Primary returns ExpBinLogica
	 *
	 * Constraint:
	 *     (left=ExpBinLogica_ExpBinLogica_1_0 right=Primary)
	 */
	protected void sequence_ExpBinLogica(ISerializationContext context, ExpBinLogica semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalitoPackage.Literals.EXPRESSAO__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalitoPackage.Literals.EXPRESSAO__LEFT));
			if (transientValues.isValueTransient(semanticObject, PascalitoPackage.Literals.EXPRESSAO__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalitoPackage.Literals.EXPRESSAO__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpBinLogicaAccess().getExpBinLogicaLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpBinLogicaAccess().getRightPrimaryParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expressao returns ExpNeg
	 *     ExpNeg returns ExpNeg
	 *
	 * Constraint:
	 *     nega=Expressao
	 */
	protected void sequence_ExpNeg(ISerializationContext context, ExpNeg semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalitoPackage.Literals.EXP_NEG__NEGA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalitoPackage.Literals.EXP_NEG__NEGA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpNegAccess().getNegaExpressaoParserRuleCall_1_0(), semanticObject.getNega());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Comando returns Loop
	 *     Loop returns Loop
	 *
	 * Constraint:
	 *     (se=Expressao faca+=Comando*)
	 */
	protected void sequence_Loop(ISerializationContext context, Loop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expressao returns N_Comutativa
	 *     Comutativa returns N_Comutativa
	 *     Comutativa.Comutativa_1_0 returns N_Comutativa
	 *     N_Comutativa returns N_Comutativa
	 *     N_Comutativa.N_Comutativa_1_0 returns N_Comutativa
	 *     ExpBinLogica returns N_Comutativa
	 *     ExpBinLogica.ExpBinLogica_1_0 returns N_Comutativa
	 *     Primary returns N_Comutativa
	 *
	 * Constraint:
	 *     (left=N_Comutativa_N_Comutativa_1_0 right=ExpBinLogica)
	 */
	protected void sequence_N_Comutativa(ISerializationContext context, N_Comutativa semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalitoPackage.Literals.EXPRESSAO__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalitoPackage.Literals.EXPRESSAO__LEFT));
			if (transientValues.isValueTransient(semanticObject, PascalitoPackage.Literals.EXPRESSAO__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalitoPackage.Literals.EXPRESSAO__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getN_ComutativaAccess().getN_ComutativaLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getN_ComutativaAccess().getRightExpBinLogicaParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expressao returns NumberLiteral
	 *     Comutativa returns NumberLiteral
	 *     Comutativa.Comutativa_1_0 returns NumberLiteral
	 *     N_Comutativa returns NumberLiteral
	 *     N_Comutativa.N_Comutativa_1_0 returns NumberLiteral
	 *     ExpBinLogica returns NumberLiteral
	 *     ExpBinLogica.ExpBinLogica_1_0 returns NumberLiteral
	 *     Primary returns NumberLiteral
	 *     NumberLiteral returns NumberLiteral
	 *
	 * Constraint:
	 *     {NumberLiteral}
	 */
	protected void sequence_NumberLiteral(ISerializationContext context, NumberLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Procedimento returns Procedimento
	 *
	 * Constraint:
	 *     (name=ID (parametro+=Variavel parametro+=Variavel*)? bloco=Bloco)
	 */
	protected void sequence_Procedimento(ISerializationContext context, Procedimento semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Programa returns Programa
	 *
	 * Constraint:
	 *     (Ident=EString bloco=Bloco)
	 */
	protected void sequence_Programa(ISerializationContext context, Programa semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalitoPackage.Literals.PROGRAMA__IDENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalitoPackage.Literals.PROGRAMA__IDENT));
			if (transientValues.isValueTransient(semanticObject, PascalitoPackage.Literals.PROGRAMA__BLOCO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalitoPackage.Literals.PROGRAMA__BLOCO));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProgramaAccess().getIdentEStringParserRuleCall_1_0(), semanticObject.getIdent());
		feeder.accept(grammarAccess.getProgramaAccess().getBlocoBlocoParserRuleCall_3_0(), semanticObject.getBloco());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Variavel returns Variavel
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Variavel(ISerializationContext context, Variavel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalitoPackage.Literals.VARIAVEL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalitoPackage.Literals.VARIAVEL__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariavelAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
}
